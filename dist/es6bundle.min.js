import{more}from"trans-render/transform.js";import{templStampSym as templStampSym$1}from"trans-render/standardPlugins.js";import{createTemplate}from"trans-render/createTemplate.js";import{p,symbolize,XtalFetchViewElement,mergeProps,define as define$3}from"xtal-element/XtalFetchViewElement.js";import{PD}from"p-et-alia/p-d.js";import{define,XtalElement}from"xtal-element/XtalElement.js";import{define as define$1,XtalElement as XtalElement$1}from"xtal-element/XtalElement";import{define as define$2}from"xtal-element/xtal-latx.js";import"xtal-editor/src/xtal-editor-base-primitive.js";import{templStampSym}from"trans-render/plugins/templStamp.js";const mainTemplate=createTemplate(`\n  <style>\n      :host{\n          display:block;\n      }\n      label{\n          display:block;\n      }\n  </style>\n  <label for=myInput part=label></label>\n  <input id=myInput part=input>\n`);const[label$,input$]=[Symbol("label"),Symbol("input")];const initTransform=({self:self})=>({label:label$,input:[{},{input:self.handleInput},,,input$]});const updateLabel=({name:name})=>({[label$]:name+":"});const updateInput=({readOnly:readOnly,inputType:inputType,disabled:disabled,value:value})=>({[input$]:[{},,{readonly:readOnly,type:inputType,disabled:disabled,value:value}]});const updateTransforms=[updateLabel,updateInput];const linkInputType=({type:type,self:self})=>{switch(type){case"boolean":self.inputType="checkbox";break;case"number":self.inputType="number";break;case"string":self.inputType="text";break}};const linkEditedValue=({value:value,self:self})=>{self.editedValue=value};class SwagTagPrimitiveBase extends XtalElement{constructor(){super();this.readyToInit=true;this.mainTemplate=mainTemplate;this.readyToRender=true;this.initTransform=initTransform;this.propActions=[linkInputType,linkEditedValue];this.updateTransforms=updateTransforms;this.eventScopes=[[,"bubbles"]]}handleInput(e){this.editedValue=e.target.value}}SwagTagPrimitiveBase.is="swag-tag-primitive-base";SwagTagPrimitiveBase.attributeProps=({readOnly:readOnly,type:type,testValues:testValues,value:value,disabled:disabled,eventScopes:eventScopes,name:name,description:description,inputType:inputType,editedValue:editedValue})=>({bool:[readOnly,disabled],async:[readOnly,inputType,disabled,value],str:[type,value,name,description,inputType,editedValue],notify:[editedValue],obj:["default",testValues,eventScopes],jsonProp:[eventScopes],reflect:[readOnly,type,disabled,name,inputType]});define(SwagTagPrimitiveBase);import("@power-elements/json-viewer/json-viewer.js");const mainTemplate$1=createTemplate(`\n<style>\ndetails{\n    max-height: 300px;\n    overflow-y:auto;\n}\n</style>\n<details open>\n    <summary>Event History</summary>\n    <json-viewer -object></json-viewer>\n</details>\n`);const jsonViewer=Symbol("json-viewer");const details=Symbol("details");const initTransform$1={details:{"json-viewer":jsonViewer},'"':[{style:{display:"none"}},,,,details]};const allowList=["detail","type","bubbles","cancelBubble","cancelable","composed","defaultPrevented","eventPhase","isTruted","returnValue","timeStamp"];const appendToEventArchive=({newEvent:newEvent,self:self})=>{if(newEvent===undefined)return;const safeEvent={};allowList.forEach((prop=>{safeEvent[prop]=newEvent[prop]}));if(self.eventArchive===undefined){self.eventArchive={eventHistory:[]}}self.eventArchive.eventHistory.unshift(safeEvent);self.eventArchive=self.eventArchive};const bindJsonViewer=({eventArchive:eventArchive})=>({[jsonViewer]:[{object:eventArchive}],[details]:[{style:{display:"block"}}]});const updateTransforms$1=[bindJsonViewer];class JsonEventViewer extends XtalElement$1{constructor(){super(...arguments);this.readyToInit=true;this.mainTemplate=mainTemplate$1;this.readyToRender=true;this.initTransform=initTransform$1;this.propActions=[appendToEventArchive];this.updateTransforms=updateTransforms$1}}JsonEventViewer.is="json-event-viewer";JsonEventViewer.attributeProps=({newEvent:newEvent,eventArchive:eventArchive})=>({obj:[newEvent,eventArchive]});define$1(JsonEventViewer);const mainTemplate$2=createTemplate(`\n  <style>\n      :host{\n          display:block;\n      }\n      label{\n          display:block\n      }\n  </style>\n  <main>\n    <label for=myInput part=label></label>\n    <xtal-editor-base-primitive key=root part=xtalEditor></xtal-editor-base-primitive>\n  </main>\n`);const uiRefs={label:Symbol("label"),xtalEditor:Symbol("xtalEditor")};const initTransform$2=({self:self,handleChange:handleChange})=>({":host":[templStampSym,uiRefs],[uiRefs.xtalEditor]:[{},{"parsed-object-changed":handleChange}]});const updateLabel$1=({name:name})=>({[uiRefs.label]:[{textContent:name+":"}]});const updateJsonEditor=({value:value,name:name})=>({[uiRefs.xtalEditor]:[{value:value}]});const linkParsedObject=({value:value,self:self})=>{try{const parsed=JSON.parse(value);self.parsedObject=parsed}catch(e){}};const propActions=[linkParsedObject,linkInputType];class SwagTagJsonEditor extends SwagTagPrimitiveBase{constructor(){super(...arguments);this.propActions=propActions;this.mainTemplate=mainTemplate$2;this.initTransform=initTransform$2;this.updateTransforms=[updateLabel$1,updateJsonEditor]}handleChange(e){this.parsedObject=e.target.parsedObject}}SwagTagJsonEditor.is="swag-tag-json-editor";SwagTagJsonEditor.attributeProps=({parsedObject:parsedObject})=>({obj:[parsedObject],notify:[parsedObject]});define$2(SwagTagJsonEditor);const mainTemplate$3=createTemplate(`\n<style id=0f0d62e5-0d00-4e70-ad90-277fcd94c963>\n  fieldset[data-guid="0f0d62e5-0d00-4e70-ad90-277fcd94c963"]>legend{\n    cursor: pointer;\n  }\n  fieldset[data-guid="0f0d62e5-0d00-4e70-ad90-277fcd94c963"][data-open="false"]>[part="scrollableArea"]{\n    display: none;\n  }\n  fieldset[data-guid="0f0d62e5-0d00-4e70-ad90-277fcd94c963"][data-open="true"]>[part="scrollableArea"]{\n    max-height: 500px;\n    overflow-y:auto;\n    display:flex;\n    flex-direction: column;\n  }\n</style>\n<main>\n\x3c!-- pass down edited values / parsed objects to demo component --\x3e\n<p-d on=edited-value-changed to=section -care-of val=target.editedValue prop-from-event=target.name m=1 skip-init></p-d>\n<p-d on=parsed-object-changed to=section -care-of val=target.parsedObject prop-from-event=target.name m=1 skip-init></p-d>\n<header part=header>\n</header>\n<section part=section>\n  <div part=componentHolder>\n    <div part=componentListeners></div>\n  </div>\n</section>\n<json-event-viewer -new-event part=jsonEventViewer></json-event-viewer>\n<form part=propsEditor>\n  <fieldset data-open="true" data-guid="0f0d62e5-0d00-4e70-ad90-277fcd94c963" part=fieldset>\n    <legend part=legend><span part=action>Edit</span> <var part=componentName></var>'s properties</legend>\n    <div part=scrollableArea>\n    </div>\n  </fieldset>\n</form>\n\n<details part=viewSchema>\n  <summary>View Schema</summary>\n  <json-viewer part=jsonViewer allowlist="name,properties,attributes,slots,events"></json-viewer>\n</details>\n\n</main>\n`);const eventListenerForJsonViewer=T(`\n<p-d from=section to=${JsonEventViewer.is}[-new-event] val=. skip-init m=1></p-d>\n`);const uiRefs$1={componentName:p,header:p,componentHolder:p,componentListeners:p,jsonViewer:p,fieldset:p,scrollableArea:p,legend:p};symbolize(uiRefs$1);const initTransform$3=({self:self,tag:tag})=>({":host":[templStampSym$1,uiRefs$1],[uiRefs$1.legend]:[{},{click:self.toggleForm}],main:{"[-care-of]":tag}});const bindName=({name:name,innerTemplate:innerTemplate})=>({[uiRefs$1.header]:`<${name}>`,[uiRefs$1.componentName]:name,[uiRefs$1.componentHolder]:[name,"afterBegin"],[more]:{[uiRefs$1.componentHolder]:{[name]:({target:target})=>{if(innerTemplate!==undefined){target.appendChild(innerTemplate.content.cloneNode(true))}}}}});const addEventListeners=({events:events,name:name})=>({[uiRefs$1.componentListeners]:[events||[],eventListenerForJsonViewer,,{[PD.is]:({item:item})=>[{observe:name,on:item.name}]}]});const copyPropInfoIntoEditor=({item:item,target:target})=>{Object.assign(target,item);target.setAttribute("role","textbox")};const copyPropInfoIntoEditors={[`${SwagTagPrimitiveBase.is},${SwagTagJsonEditor.is}`]:copyPropInfoIntoEditor};const addEditors=({massagedProps:massagedProps,name:name})=>({[uiRefs$1.scrollableArea]:[massagedProps||[],({item:item})=>item.editor,,copyPropInfoIntoEditors]});const bindSelf=({attribs:attribs,self:self})=>({[uiRefs$1.jsonViewer]:[{object:self}]});const updateTransforms$2=[bindName,addEventListeners,addEditors,bindSelf];const linkWcInfo=({viewModel:viewModel,tag:tag,self:self})=>{if(tag===undefined||viewModel===undefined)return;const wcInfo=viewModel.tags.find((t=>t.name===tag));wcInfo.attribs=wcInfo.attributes;delete wcInfo.attributes;Object.assign(self,wcInfo)};function adjustValueAndType(prop){let defaultVal=prop.default;let parsedType=undefined;if(defaultVal!==undefined){try{defaultVal=JSON.parse(defaultVal);parsedType=JSON.parse("["+prop.type.replace(/\|/g,",")+"]")}catch(e){}if(Array.isArray(parsedType)){prop.value=defaultVal;prop.type="stringArray";prop.options=parsedType;return}switch(typeof defaultVal){case"object":prop.value=prop.default;prop.type="object";break;case"string":prop.value=defaultVal;prop.type="string";break;case"number":prop.value=defaultVal;prop.type="number";break;case"boolean":prop.value=defaultVal;prop.type="boolean";break;default:prop.value=prop.default;prop.type="object"}}else{switch(prop.type){case"string":case"boolean":case"number":break;default:prop.type="object"}}}const massaged=Symbol();const linkMassagedProps=({properties:properties,self:self,block:block})=>{if(properties===undefined||properties[massaged])return;properties.forEach((prop=>{adjustValueAndType(prop);const anyProp=prop;switch(prop.type){case"string":case"number":case"boolean":anyProp.editor=SwagTagPrimitiveBase.is;break;case"object":anyProp.editor=SwagTagJsonEditor.is;break;default:throw"not implemented"}}));properties[massaged]=true;self.massagedProps=block!==undefined?properties.filter((prop=>!block.includes(prop.name))):properties};const linkInnerTemplate=({useInnerTemplate:useInnerTemplate,self:self})=>{if(!useInnerTemplate)return;const innerTemplate=self.querySelector("template");if(innerTemplate===null){setTimeout((()=>{linkInnerTemplate(self)}),50);return}self.innerTemplate=innerTemplate};const triggerImportReferencedModule=({path:path,self:self,skipImports:skipImports})=>{if(path!==undefined&&!skipImports){if(self.href.indexOf("//")>-1&&self.href.indexOf("//")<7){const selfResolvingModuleSplitPath=self.href.split("/");selfResolvingModuleSplitPath.pop();const selfResolvingModulePath=selfResolvingModuleSplitPath.join("/")+self.path.substring(1)+"?module";import(selfResolvingModulePath)}else{const splitPath=(location.origin+location.pathname).split("/");splitPath.pop();let path=self.path;while(path.startsWith("../")){splitPath.pop();path=path.substr(3)}const importPath=splitPath.join("/")+"/"+path;import(importPath)}}};const showHideEditor=({editOpen:editOpen,self:self})=>{self[uiRefs$1.fieldset].dataset.open=(editOpen||false).toString()};class SwagTag extends XtalFetchViewElement{constructor(){super(...arguments);this.noShadow=true;this.mainTemplate=mainTemplate$3;this.readyToRender=true;this.propActions=[linkWcInfo,linkMassagedProps,triggerImportReferencedModule,showHideEditor,linkInnerTemplate];this.initTransform=initTransform$3;this.updateTransforms=updateTransforms$2;this.skipImports=false}toggleForm(e){this.editOpen=!this.editOpen}}SwagTag.is="swag-tag";SwagTag.attributeProps=({tag:tag,name:name,properties:properties,path:path,events:events,slots:slots,testCaseNames:testCaseNames,attribs:attribs,editOpen:editOpen,block:block,useInnerTemplate:useInnerTemplate,innerTemplate:innerTemplate,skipImports:skipImports})=>{const ap={str:[tag,name,path],bool:[editOpen,useInnerTemplate,skipImports],obj:[properties,events,slots,testCaseNames,attribs,block,innerTemplate],jsonProp:[block],reflect:[tag,editOpen]};return mergeProps(ap,XtalFetchViewElement.props)};define$3(SwagTag);export{SwagTag,addEditors,addEventListeners,adjustValueAndType,bindName,bindSelf,copyPropInfoIntoEditor,linkInnerTemplate,linkMassagedProps,linkWcInfo,showHideEditor,triggerImportReferencedModule,uiRefs$1 as uiRefs};
